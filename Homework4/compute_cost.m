%本函数从图片的顶部到低端，求取最小cost的路径
function [cost, paths]=compute_cost(~, energy, axis)

%     从第一行开始,计算每一个像素点的累积能量和，即cost。像素点的cost定义为从顶部开始，同一seam上像素点的累积能量和的最小值.
% 
%     同时，我们需要返回这条路径。路径上的每个像素点的值只有三种可能：-1,0,以及1，-1表示当前像素点与它的左上角的元素相连，0表示当前像素点
%     与它正上方的元素相连，而1表示当前像素点与它右上方的元素相连。
%     比如，对于一个3*3的矩阵，如果点(2,2)的值为-1, 则表示点(2,2)与点(1,1)相连接。
% 
%     当能量相同的时候,我们规定选取最左边的路径。
%     
%     提示：由于这个函数会被大量使用，如果循环过多的话，会使程序运行速度变慢的.
%           正常情况下，你只会进行一次列循环，而不会对每一行的元素进行循环。
%           假如你现在是对(i,j)号元素求cost，那么(i,j)号元素只可能与(i-1,j-1)、(i-1,j)，或者(i-1,j+1)号元素相连,并且是其中的最小者。
%           为了避免对每一行的元素都进行循环，我们可以进行向量化操作。
%           
%           举例：假设我们的energy = [1, 2, 3; 4, 5, 6]，现在我们需要确定第二行元素[4, 5, 6]分别是和第一行的哪几个元素相连接，那么我们
%           只需要构造一个新的矩阵M = [99, 1, 2;1, 2, 3;2, 3, 99];矩阵M的第一列代表元素4的可能对应的三个元素，即：[无穷大，1，2]；第二列
%           代表元素5可能对应的三个元素，即[1, 2, 3]；第三列代表元素6可能对应的三个元素，即[2, 3, 无穷大]。
%           通过这种方式，我们只需要对矩阵M沿着竖直方向求一次最小值，就可以把第二行所对应的元素全部都求出来了。避免了对每一行的元素进行循环。
% 
%     参数:
%         image: 该函数里面没有使用
%                (留在这是为了和 compute_forward_cost 函数有一个相同的接口)
%         energy: 形状为 (H, W) 的数组
%         axis: 确定沿着哪个轴计算(axis=0为水平方向，axis=1为竖直方向)
% 
%     返回值:
%         cost: 形状为 (H, W) 的数组，保存累积的损失
%         paths: 形状为 (H, W) 的数组，数组元素为 -1, 0
%         或者1。-1表示与左上角元素相连，0表示与正上方元素相连，1表示与右上方元素相连。

    if axis == 0
        energy = energy';
    end

    [H, W] = size(energy);

    cost = zeros(H,W);
    paths = zeros(H,W);

    % 初始化
    cost(1,:) = energy(1,:); %第一行的cost就是它本身
    paths(1,:) = 0;  % 对于第一行，我们并不在意

%   你的代码
for a = 2: H
    M = size(3, W);
    for i = 1: W
        for j = 1: 3
            if i == 1 && j == 1
                M(1, 1) = 99;
            elseif i == W && j == 3
                    M(3, W) = 99;
            else 
                M(j, i) = cost(a - 1, i + j - 2);
            end
        end
    end
    for j = 1: W
        m = 99;
        for i = 1: 3
            if M(i, j) < m
                m = M(i, j);
                if i == 1
                    paths(a, j) = -1;
                elseif i == 2
                    paths(a, j) = 0;
                else
                    paths(a, j) = 1;
                end
            end
        end
        cost(a, j) = m + energy(a, j); 
    end
end
%   你的代码

    if axis == 0
        cost = cost';
        paths = paths';
    end

end